webpackJsonp([10],{1525:function(n,e,t){var o=t(1),s=t(14),r=t(15).PageRenderer;r.__esModule&&(r=r.default);var a=s({displayName:"WrappedPageRenderer",getInitialState:function(){return{content:t(1558)}},componentWillMount:function(){},render:function(){return o.createElement(r,Object.assign({},this.props,{content:this.state.content}))}});a.__catalog_loader__=!0,n.exports=a},1558:function(n,e){n.exports="[![build status](https://secure.travis-ci.org/reactabular/easy.svg)](http://travis-ci.org/reactabular/easy) [![bitHound Score](https://www.bithound.io/github/reactabular/easy/badges/score.svg)](https://www.bithound.io/github/reactabular/easy) [![codecov](https://codecov.io/gh/reactabular/easy/branch/master/graph/badge.svg)](https://codecov.io/gh/reactabular/easy)\n\n# reactabular-easy - Easy, opinionated wrapper for Reactabular\n\nGiven Reactabular is flexible by design, it's not the easiest to use and you may have to do quite a bit of wiring to make it work the way you want. *reactabular-easy* has been designed to make using it easier. It is opinionated and takes away some power. But on the plus side it allows you to render a fully featured table faster.\n\n## How to Use?\n\nTo make the drag and drop functionality work, you have to set up [react-dnd-html5-backend](https://www.npmjs.com/package/react-dnd-html5-backend) or some other React DnD backend.\n\n> You can find suggested default styling for the package at `style.css` in the package root.\n\n> If you want to use the drag and drop functionality, you have to set up React DnD!\n\n```jsx\n/*\nimport React from 'react';\nimport * as resolve from 'table-resolver';\nimport * as dnd from 'reactabular-dnd';\nimport * as easy from 'reactabular-easy';\nimport VisibilityToggles from 'react-visibility-toggles';\nimport * as resizable from 'reactabular-resizable';\nimport * as tree from 'treetabular';\nimport * as search from 'searchtabular';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport { DragDropContext } from 'react-dnd';\nimport { compose } from 'redux';\nimport uuid from 'uuid';\nimport cloneDeep from 'lodash/cloneDeep';\nimport findIndex from 'lodash/findIndex';\n\nimport {\n  generateParents, generateRows\n} from './helpers';\n*/\n\nconst schema = {\n  type: 'object',\n  properties: {\n    Id: {\n      type: 'string'\n    },\n    fullName: {\n      $ref: '#/definitions/fullName'\n    },\n    company: {\n      type: 'string'\n    },\n    age: {\n      type: 'integer'\n    },\n    boss: {\n      $ref: '#/definitions/boss'\n    }\n  },\n  required: ['Id', 'fullName', 'company', 'age', 'boss'],\n  definitions: {\n    boss: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string'\n        }\n      },\n      required: ['name']\n    },\n    fullName: {\n      type: 'object',\n      properties: {\n        first: {\n          type: 'string'\n        },\n        last: {\n          type: 'string'\n        }\n      },\n      required: ['first', 'last']\n    }\n  }\n};\nconst rows = generateParents(generateRows(200, schema), 'Id');\n\nclass EasyDemo extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      rows,\n      columns: this.getColumns(),\n      sortingColumns: {},\n      query: {},\n      hiddenColumns: {} // <id>: <hidden> - show all by default\n    };\n    this.table = null;\n\n    this.onMoveRow = this.onMoveRow.bind(this);\n    this.onDragColumn = this.onDragColumn.bind(this);\n    this.onMoveColumns = this.onMoveColumns.bind(this);\n    this.onToggleColumn = this.onToggleColumn.bind(this);\n    this.onSelectRow = this.onSelectRow.bind(this);\n    this.onRemove = this.onRemove.bind(this);\n    this.onSort = this.onSort.bind(this);\n    this.onToggleShowingChildren = this.onToggleShowingChildren.bind(this);\n  }\n  componentWillMount() {\n    this.resizableHelper = resizable.helper({\n      globalId: uuid.v4(),\n      getId: ({ id }) => id\n    });\n  }\n  componentWillUnmount() {\n    this.resizableHelper.cleanup();\n  }\n  getColumns() {\n    return [\n      {\n        id: 'demo', // Unique ids for handling visibility checks\n        header: {\n          label: 'Demo',\n          draggable: true,\n          resizable: true,\n          formatters: [\n            () => <span>Testing</span>\n          ]\n        },\n        cell: {\n          formatters: [\n            () => <span>Demo</span>,\n          ],\n          toggleChildren: true\n        },\n        width: 100\n      },\n      {\n        id: 'name',\n        header: {\n          label: 'Name'\n          // Disabled for now as this is a difficult case in React DnD\n          //draggable: true\n        },\n        children: [\n          {\n            id: 'firstName',\n            property: 'fullName.first',\n            header: {\n              label: 'First Name',\n              draggable: true,\n              sortable: true,\n              resizable: true\n            },\n            cell: {\n              highlight: true\n            },\n            width: 125\n          },\n          {\n            id: 'lastName',\n            property: 'fullName.last',\n            header: {\n              label: 'Last Name',\n              draggable: true,\n              sortable: true,\n              resizable: true\n            },\n            cell: {\n              highlight: true\n            },\n            width: 125\n          }\n        ]\n      },\n      {\n        id: 'age',\n        property: 'age',\n        header: {\n          label: 'Age',\n          draggable: true,\n          sortable: true,\n          resizable: true\n        },\n        cell: {\n          highlight: true\n        },\n        width: 150\n      },\n      {\n        id: 'company',\n        property: 'company',\n        header: {\n          label: 'Company',\n          draggable: true,\n          sortable: true,\n          resizable: true\n        },\n        cell: {\n          highlight: true\n        },\n        width: 250\n      },\n      {\n        id: 'bossName',\n        property: 'boss.name',\n        header: {\n          label: 'Boss',\n          draggable: true,\n          sortable: true,\n          resizable: true\n        },\n        cell: {\n          highlight: true\n        },\n        width: 200\n      },\n      {\n        cell: {\n          formatters: [\n            (value, { rowData }) => (\n              <div>\n                <input\n                  type=\"button\"\n                  value=\"Click me\"\n                  onClick={() => alert(`${JSON.stringify(rowData, null, 2)}`)}\n                />\n                <span\n                  className=\"remove\"\n                  onClick={() => this.onRemove(rowData.Id)}\n                  style={{ marginLeft: '1em', cursor: 'pointer' }}\n                >\n                  &#10007;\n                </span>\n              </div>\n            )\n          ]\n        },\n        width: 200\n      }\n    ];\n  }\n  render() {\n    const {\n      searchColumn, columns, sortingColumns, rows, query, hiddenColumns\n    } = this.state;\n    const idField = 'Id';\n    const parentField = 'parent';\n\n    const visibleColumns = compose(\n      // 5. Patch columns with classNames for resizing\n      this.resizableHelper.initialize,\n      // 4. Bind columns (extra functionality)\n      easy.bindColumns({\n        toggleChildrenProps: { className: 'toggle-children' },\n        sortingColumns,\n        rows,\n        idField,\n        parentField,\n        props: this.props,\n\n        // Handlers\n        onMoveColumns: this.onMoveColumns,\n        onSort: this.onSort,\n        onDragColumnStart: (width, extra) => console.log('drag column start', width, extra),\n        onDragColumn: this.onDragColumn,\n        onDragColumnEnd: (width, extra) => console.log('drag column end', width, extra),\n        onToggleShowingChildren: this.onToggleShowingChildren\n      }),\n      // 3. Filter based on visibility again (children level)\n      columns => columns.filter(column => !hiddenColumns[column.id]),\n      // 2. Unpack\n      tree.unpack(),\n      // 1. Filter based on visibility (root level)\n      columns => columns.filter(column => !hiddenColumns[column.id])\n    )(columns);\n    const columnChildren = visibleColumns.filter(column => !column._isParent);\n    const headerRows = resolve.headerRows({\n      columns: tree.pack()(visibleColumns)\n    });\n\n    return (\n      <div>\n        <VisibilityToggles\n          columns={tree.unpack()(columns)}\n          onToggleColumn={this.onToggleColumn}\n          isVisible={({ column: { id } }) => !hiddenColumns[id]}\n        />\n\n        <div className=\"scroll-container\">\n          <label>Scroll to index: </label>\n          <div>\n            <input\n              type=\"text\"\n              onChange={e => this.table.tableBody.scrollTo(e.target.value)}\n            />\n          </div>\n        </div>\n\n        <div className=\"search-container\">\n          <span>Search</span>\n          <search.Field\n            column={searchColumn}\n            query={query}\n            columns={columnChildren}\n            rows={rows}\n            onColumnChange={searchColumn => this.setState({ searchColumn })}\n            onChange={query => this.setState({ query })}\n          />\n        </div>\n\n        <easy.Table\n          ref={table => {\n            this.table = table\n          }}\n          rows={rows}\n          headerRows={headerRows}\n          rowKey=\"Id\"\n          sortingColumns={sortingColumns}\n          tableWidth={800}\n          tableHeight={400}\n          columns={columnChildren}\n          query={query}\n          classNames={{\n            table: {\n              wrapper: 'pure-table pure-table-striped'\n            }\n          }}\n          headerExtra={\n            <search.Columns\n              query={query}\n              columns={columnChildren}\n              onChange={query => this.setState({ query })}\n            />\n          }\n\n          idField={idField}\n          parentField={parentField}\n\n          onMoveRow={this.onMoveRow}\n          onSelectRow={this.onSelectRow}\n        />\n      </div>\n    );\n  }\n  onMoveRow({ sourceRowId, targetRowId }) {\n    const rows = tree.moveRows({\n      operation: dnd.moveRows({\n        sourceRowId,\n        targetRowId,\n        idField: 'Id'\n      }),\n      idField: 'Id', // Defaults to id\n      parentField: 'parent'\n    })(this.state.rows);\n\n    rows && this.setState({ rows });\n  }\n  onDragColumn(width, { column }) {\n    this.resizableHelper.update({\n      column,\n      width\n    });\n  }\n  onMoveColumns({ sourceLabel, targetLabel }) {\n    const columns = tree.unpack()(this.state.columns);\n\n    const sourceIndex = findIndex(\n      columns,\n      { header: { label: sourceLabel } }\n    );\n    const targetIndex = findIndex(\n      columns,\n      { header: { label: targetLabel } }\n    );\n\n    if (sourceIndex < 0 || targetIndex < 0) {\n      return null;\n    }\n\n    let source = columns[sourceIndex];\n    let target = columns[targetIndex];\n\n    if (source._isParent) {\n      return console.warn(\n        'Dragging parents is not supported yet'\n      );\n    }\n\n    // If source doesn't have a parent, make sure we are dragging to\n    // target parent by modifying the original structure.\n    if (!source.parent) {\n      const targetParents = tree.getParents({\n        index: findIndex(columns, { id: target.id })\n      })(columns);\n\n      // If trying to drag to a child, drag to its root\n      // parent instead.\n      if (targetParents.length) {\n        return console.warn(\n          'Dragging to a nested column is not supported yet'\n        );\n      }\n\n      const nestedSourceIndex = findIndex(\n        this.state.columns,\n        { header: { label: sourceLabel } }\n      );\n      source = this.state.columns[nestedSourceIndex];\n\n      const nestedTargetIndex = findIndex(\n        this.state.columns,\n        { header: { label: target.header.label } }\n      );\n      target = this.state.columns[nestedTargetIndex];\n\n      if (nestedSourceIndex < 0 || nestedTargetIndex < 0) {\n        return null;\n      }\n\n      // We are operating at root level now so move accordingly.\n      const movedColumns = dnd.move(\n        this.state.columns, nestedSourceIndex, nestedTargetIndex\n      );\n\n      // Retain widths while moving\n      movedColumns[nestedSourceIndex].width = source.width;\n      movedColumns[nestedTargetIndex].width = target.width;\n\n      this.setState({\n        columns: movedColumns\n      });\n    } else if (source.parent === target.parent) {\n      // Dragging within children now. This has to be against flattened data.\n      const movedColumns = dnd.move(columns, sourceIndex, targetIndex);\n\n      // Retain widths while moving.\n      // XXX: This works only for single level nesting.\n      const sourceWidth = source.width;\n      const targetWidth = target.width;\n\n      source.width = targetWidth;\n      target.width = sourceWidth;\n\n      this.setState({\n        columns: tree.pack()(movedColumns)\n      });\n    }\n    // If trying to drag from children to other children or so, do nothing.\n  }\n  onSelectRow({ selectedRowId, selectedRow }) {\n    console.log('onSelectRow', selectedRowId, selectedRow);\n  }\n  onSort(sortingColumns) {\n    console.log('onSort', sortingColumns);\n\n    this.setState({ sortingColumns });\n  }\n  onToggleColumn({ column }) {\n    const { hiddenColumns } = this.state;\n\n    this.setState({\n      hiddenColumns: {\n        ...hiddenColumns,\n        [column.id]: !hiddenColumns[column.id]\n      }\n    });\n  }\n  onRemove(id) {\n    const rows = cloneDeep(this.state.rows);\n    const idx = findIndex(rows, { Id });\n\n    // this could go through flux etc.\n    rows.splice(idx, 1);\n\n    this.setState({ rows });\n  }\n  onToggleShowingChildren(rowIndex) {\n    const rows = cloneDeep(this.state.rows);\n\n    rows[rowIndex].showingChildren = !rows[rowIndex].showingChildren;\n\n    this.setState({ rows });\n  //},\n  }\n}\n\n// Set up drag and drop context\n// const DragAndDropDemo = DragDropContext(HTML5Backend)(EasyDemo);\n\n<EasyDemo />\n\n/*\nexport default EasyDemo\n*/\n```\n\n## Styling\n\nIt is possible to pass custom `classNames` and `props` as listed below:\n\n```js\nclassNames: {\n  table: null,\n  header: {\n    wrapper: null\n    // TODO\n    /*\n    row: null,\n    cell: null\n    */\n  },\n  body: {\n    wrapper: null\n    // TODO\n    /*\n    row: null,\n    cell: null\n    */\n  }\n},\nprops: {\n  resize: {\n    container: {\n      style: {\n        color: 'red'\n      }\n    },\n    value: {},\n    handle: {}\n  },\n  sort: {\n    container: {},\n    value: {},\n    order: {}\n  }\n}\n```\n\nFor more control, you can also override `components` and also inject styling and class names through the column definition and the `onRow` handler.\n\n## Customization\n\nIf you want to customize resize/sort controls further (add `className`s etc.), pass `props` like this:\n\n```javascript\nprops: {\n  resize: {\n    container: {},\n    value: {},\n    handle: {}\n  },\n  sort: {\n    container: {},\n    value: {},\n    order: {}\n  }\n},\n```\n\n## License\n\nMIT.\n"}});