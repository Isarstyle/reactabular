webpackJsonp([6],{1510:function(e,n,o){var t=o(1),r=o(14),s=o(15).PageRenderer;s.__esModule&&(s=s.default);var a=r({displayName:"WrappedPageRenderer",getInitialState:function(){return{content:o(1543)}},componentWillMount:function(){},render:function(){return t.createElement(s,Object.assign({},this.props,{content:this.state.content}))}});a.__catalog_loader__=!0,e.exports=a},1543:function(e,n){e.exports="[![build status](https://secure.travis-ci.org/reactabular/table-resolver.svg)](http://travis-ci.org/reactabular/table-resolver) [![bitHound Score](https://www.bithound.io/github/reactabular/table-resolver/badges/score.svg)](https://www.bithound.io/github/reactabular/table-resolver) [![codecov](https://codecov.io/gh/reactabular/table-resolver/branch/master/graph/badge.svg)](https://codecov.io/gh/reactabular/table-resolver)\n\n# table-resolver - Table resolution utilities\n\nSometimes your rows might come in a nested format or it might have a representation that maps to the underlying value. A name split to first and last parts is an example of the former. Country code to country mapping is an example of the latter.\n\n```javascript\nimport * as resolve from 'table-resolver';\n\n// Or you can cherry-pick\nimport { nested } from 'table-resolver';\nimport { nested as resolveNested } from 'table-resolver';\n```\n\n## API\n\nThe API consists of two parts: **row resolvers** and **column resolvers**. If you have complex data, use the former. Latter come in handy if you have a nested column definition that needs to be flattened so that it works with a component like Reactabular.\n\n## Row Resolvers\n\n`table-resolver` uses an iterator that accepts rows and then transforms it using a specific resolver method (or several, if they have been composed into one).\n\n### `resolve.resolve`\n\n**`({ columns: <columns>, method: <resolver function>, indexKey = '_index' }) => <rows> => <rows>`**\n\nThe `resolve` iterator is the heart of this package. It accepts columns and a method. When applied with rows, it will return resolved rows. The method is a function with signature like: `({ column }) => (rowData) => <resolved row>`. In most cases, the `nested` and `byFunction` methods provided in this package (or a composition of them) will be all you need.\n\nThe `resolve` iterator automatically injects into every resolved row object a field named `_index` containing the row's index. If `method` is not provided, `_index` is injected to the data automatically.\n\nIf your own resolver (e.g. `byFunction`) happens to also output a field named `_index`, it will overwrite the default one. In that case, if you still need the row index, you may wish to pass a different `indexKey` when calling `resolve`.\n\nNote that columns are resolved in order.  This means the `rowData` passed into a custom resolver will contain properties from earlier columns.\n\n### Method `resolve.nested`\n\n**`({ column }) => (rowData) => <resolved row>`**\n\nThe `nested` resolver digs rows from a `property: 'name.first'` kind of definition and maps the received value to property name. It replaces the original value with the resolved one. *Note*: instead of defining a path string `property: 'name.first'`, you may provide a custom getter function `property: data => (data.name || {}).first` directly. This may be slightly faster but needs to be done carefully to prevent TypeErrors due to missing values.\n\nThis is not intended to be called directly.  Pass it as a method to `resolve.resolve()`.\n\n### Method creator `resolve.byFunction`\n\n**`(path: <string>) => ({ column }) => (rowData) => <resolved row>`**\n\nThe `byFunction` resolver accepts a path from where to look for a resolving function. It could be `column.cell.resolve` for example and you can use a nested definition for getting it from your column definition.\n\nInstead of replacing the original value, `byFunction` generates `_<property>` kind of field to the resulting rows. This sort of implicit rule is useful for other functionality as it can rely on the same convention.\n\nThis is not intended to be called directly.  Pass it as a method to `resolve.resolve()`.\n\n## Column Resolvers\n\n### `resolve.columnChildren`\n\n**`({ columns, childrenField = 'children' }) => <resolved columns>`**\n\nAssuming your column definition is nested, this function resolves it to a flat format.\n\n### `resolve.headerRows`\n\n**`({ columns, childrenField = 'children' }) => <resolved columns>`**\n\nIf your column definition is nested, you have to resolve it to header rows. `resolve.headerRows` has been designed exactly for this purpose.\n\n## Combining Resolver Methods\n\nYou can easily combine resolver methods like this:\n\n```javascript\nconst resolver = resolve.resolve({\n  columns,\n  method: ({ rowData, column }) => resolve.byFunction('cell.resolve')({\n    rowData: resolve.nested({ rowData, column }),\n    column\n  })\n});\n```\n\nor if you are already using Redux:\n\n```javascript\nimport { compose } from 'redux';\n\n...\n\nconst resolver = resolve.resolve({\n  columns,\n  method: (extra) => compose(\n    resolve.byFunction('cell.resolve')(extra),\n    resolve.nested(extra)\n  )\n});\n```\n\n## Resolution Example\n\nThe following example shows how you to resolve nested values.\n\n**Example:**\n\n```jsx\n/*\nimport * as resolve from 'table-resolver';\n*/\n\nconst columns = [\n  {\n    property: 'color',\n    header: {\n      label: 'Color'\n    }\n  },\n  {\n    header: {\n      label: 'Name'\n    },\n    children: [\n      {\n        property: 'name.first',\n        header: {\n          label: 'First Name'\n        }\n      },\n      {\n        property: 'name.last',\n        header: {\n          label: 'Last Name'\n        }\n      }\n    ]\n  },\n  {\n    header: {\n      label: 'About'\n    },\n    children: [\n      {\n        property: 'company',\n        header: {\n          label: 'Company'\n        }\n      },\n      {\n        property: 'sentence',\n        header: {\n          label: 'Sentence'\n        }\n      }\n    ]\n  }\n];\n\nconst rows = [\n  {\n    id: 1,\n    color: 'red',\n    name: {\n      first: 'John',\n      last: 'Johnson'\n    },\n    company: 'John Inc.',\n    sentence: 'consequatur nihil minima corporis omnis nihil rem'\n  },\n  {\n    id: 2,\n    color: 'blue',\n    name: {\n      first: 'Mike',\n      last: 'Mikeson'\n    },\n    company: 'Mike Inc.',\n    sentence: 'a sequi doloremque sed id quo voluptatem voluptatem ut voluptatibus'\n  }\n];\n\n<ul>{\n  resolve.resolve(\n    {\n      columns: resolve.columnChildren({ columns }),\n      method: resolve.nested\n    }\n  )(rows).map((d, i) =>\n    <li key={`value-${i}`}>{JSON.stringify(d, null, 2)}</li>\n  )\n}</ul>\n```\n\n## License\n\nMIT. See LICENSE for details.\n"}});