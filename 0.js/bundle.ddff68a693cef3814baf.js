webpackJsonp([0],{1523:function(n,e,t){var r=t(1),o=t(14),a=t(15).PageRenderer;a.__esModule&&(a=a.default);var i=o({displayName:"WrappedPageRenderer",getInitialState:function(){return{content:t(1556)}},componentWillMount:function(){},render:function(){return r.createElement(a,Object.assign({},this.props,{content:this.state.content}))}});i.__catalog_loader__=!0,n.exports=i},1556:function(n,e){n.exports="`reactabular-virtualized` works in conjunction with `reactabular-sticky` and provides virtualization. The idea is that instead of rendering all table cells, it renders only ones visible at the viewport. This improves performance significantly with larger datasets.\n\n> If you want extra logging during development, set `window.LOG_VIRTUALIZED = true` at console.\n\n**Example:**\n\n```jsx\n/*\nimport React from 'react';\nimport * as Sticky from 'reactabular-sticky';\nimport * as Virtualized from 'reactabular-virtualized';\nimport * as resolve from 'table-resolver';\n\nimport { generateRows } from './helpers';\n*/\n\nconst columns = [\n  {\n    property: 'id',\n    props: {\n      style: { minWidth: 50 }\n    },\n    header: {\n      label: 'Index'\n    },\n    cell: {\n      formatters: [\n        (value, { rowIndex }) => <span>{rowIndex}</span>\n      ]\n    }\n  },\n  {\n    property: 'name',\n    props: {\n      style: { minWidth: 300 }\n    },\n    header: {\n      label: 'Name'\n    }\n  },\n  {\n    property: 'age',\n    props: {\n      style: { minWidth: 100 }\n    },\n    header: {\n      label: 'Age'\n    }\n  },\n  {\n    property: 'company',\n    props: {\n      style: { minWidth: 400 }\n    },\n    header: {\n      label: 'Company'\n    }\n  },\n  {\n    property: 'product',\n    props: {\n      style: { minWidth: 400 }\n    },\n    header: {\n      label: 'Product'\n    }\n  }\n];\n\nconst schema = {\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string'\n    },\n    name: {\n      type: 'string'\n    },\n    product: {\n      type: 'string'\n    },\n    company: {\n      type: 'string'\n    },\n    age: {\n      type: 'integer'\n    }\n  },\n  required: ['id', 'name', 'product', 'company', 'age']\n};\n// Resolving indices is an optional step. You can skip it if you don't\n// rely on rowIndex anywhere. But if you do, it's good to calculate and\n// include to the data. Reactabular's rendering logic is able to pick it\n// up by convention (`_index` field).\nconst rows = resolve.resolve({ columns })(generateRows(1000, schema));\n\nclass VirtualizedTable extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      rows,\n      columns\n    };\n\n    this.tableHeader = null;\n    this.tableBody = null;\n  }\n  componentDidMount() {\n    // We have refs now. Force update to get those to Header/Body.\n    this.forceUpdate();\n  }\n  render() {\n    return (\n      <div>\n        <div>\n          <label>Scroll to index: </label>\n          <input\n            type=\"text\"\n            onChange={e => this.tableBody.scrollTo(e.target.value)}\n          />\n        </div>\n\n        <Table.Provider\n          className=\"pure-table pure-table-striped\"\n          columns={columns}\n          renderers={{\n            body: {\n              wrapper: Virtualized.BodyWrapper,\n              row: Virtualized.BodyRow\n            }\n          }}\n        >\n          <Sticky.Header\n            style={{\n              maxWidth: 800\n            }}\n            ref={tableHeader => {\n              this.tableHeader = tableHeader && tableHeader.getRef();\n            }}\n            tableBody={this.tableBody}\n          />\n\n          <Virtualized.Body\n            rows={rows}\n            rowKey=\"id\"\n            style={{\n              maxWidth: 800,\n              maxHeight: 400\n            }}\n            height={400}\n            ref={tableBody => {\n              this.tableBody = tableBody && tableBody.getRef();\n            }}\n            tableHeader={this.tableHeader}\n          />\n        </Table.Provider>\n      </div>\n    );\n  }\n}\n\n<VirtualizedTable />\n```\n\n## Scrolling within a container\n\nBy passing in a function as `container` which returns a reference to a container to `Virtualized.Body`, you can use the scrollbar of a surrounding element as the scroll for virtualization. This might be useful if you want to render multiple containers in the same scrolling area, or if you want the table to scroll along with the rest of your page.\n```jsx\n/*\nimport React from 'react';\nimport * as Sticky from 'reactabular-sticky';\nimport * as Virtualized from 'reactabular-virtualized';\nimport * as resolve from 'table-resolver';\n\nimport { generateRows } from './helpers';\n*/\n\nconst columns = [\n  {\n    property: 'id',\n    props: {\n      style: { minWidth: 50 }\n    },\n    header: {\n      label: 'Index'\n    },\n    cell: {\n      formatters: [\n        (value, { rowIndex }) => <span>{rowIndex}</span>\n      ]\n    }\n  },\n  {\n    property: 'name',\n    props: {\n      style: { minWidth: 300 }\n    },\n    header: {\n      label: 'Name'\n    }\n  },\n  {\n    property: 'age',\n    props: {\n      style: { minWidth: 100 }\n    },\n    header: {\n      label: 'Age'\n    }\n  },\n  {\n    property: 'company',\n    props: {\n      style: { minWidth: 400 }\n    },\n    header: {\n      label: 'Company'\n    }\n  },\n  {\n    property: 'product',\n    props: {\n      style: { minWidth: 400 }\n    },\n    header: {\n      label: 'Product'\n    }\n  }\n];\n\nconst schema = {\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string'\n    },\n    name: {\n      type: 'string'\n    },\n    product: {\n      type: 'string'\n    },\n    company: {\n      type: 'string'\n    },\n    age: {\n      type: 'integer'\n    }\n  },\n  required: ['id', 'name', 'product', 'company', 'age']\n};\n// Resolving indices is an optional step. You can skip it if you don't\n// rely on rowIndex anywhere. But if you do, it's good to calculate and\n// include to the data. Reactabular's rendering logic is able to pick it\n// up by convention (`_index` field).\nconst rows = resolve.resolve({ columns })(generateRows(1000, schema));\n\nclass VirtualizedTable extends React.Component {\n  render() {\n    return (\n      <div>\n       <div ref={(ref) => this.container = ref} style={{ height: '500px', overflow: 'auto' }}>\n            {([1, 2, 3]).map(count => \n            <Table.Provider\n              key={count}\n              className=\"pure-table pure-table-striped\"\n              columns={columns}\n              style={{ margin: '20px', }}\n              renderers={{\n                body: {\n                  wrapper: Virtualized.BodyWrapper,\n                  row: Virtualized.BodyRow\n                }\n              }}\n            >\n              <Table.Header\n                style={{\n                  maxWidth: 800\n                }}\n              />\n\n              <Virtualized.Body\n                container={() => this.container}\n                rows={rows}\n                rowKey=\"id\"\n                style={{\n                  maxWidth: 800\n                }}\n                height={400}\n              />\n            </Table.Provider>\n            )}\n        </div>\n      </div>\n    );\n  }\n}\n\n<VirtualizedTable />\n```\n\n## Scrolling to Index\n\n`Virtualized.Body` `ref` exposes `scrollTo` method for scrolling through index. If you want to scroll based on some field value, search the dataset first and pass the resulting index here.\n\n## Define the Height of Table\n\nPlease note `height` of `<Virtualized.Body>` must be defined. If `height` is not defined, `style.maxHeight` will be used. In below example, we use `style.maxHeight` instead of `height`,\n\n```jsx\n/*\nimport React from 'react';\nimport * as Sticky from 'reactabular-sticky';\nimport * as Virtualized from 'reactabular-virtualized';\n\nimport { generateRows } from './helpers';\n*/\n\nconst columns = [\n  {\n    property: 'id',\n    props: {\n      style: { minWidth: 350 }\n    },\n    header: {\n      label: 'Index'\n    }\n  },\n  {\n    property: 'name',\n    props: {\n      style: { minWidth: 300 }\n    },\n    header: {\n      label: 'Name'\n    }\n  }\n];\nconst schema = {\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string'\n    },\n    name: {\n      type: 'string'\n    }\n  },\n  required: ['id', 'name']\n};\nconst rows = generateRows(1000, schema);\n\nclass VirtualizedTable extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      rows,\n      columns\n    };\n\n    this.tableHeader = null;\n    this.tableBody = null;\n  }\n  componentDidMount() {\n    // We have refs now. Force update to get those to Header/Body.\n    this.forceUpdate();\n  }\n  render() {\n    return (\n      <div>\n        <Table.Provider\n          className=\"pure-table pure-table-striped\"\n          columns={columns}\n          renderers={{\n            body: {\n              wrapper: Virtualized.BodyWrapper,\n              row: Virtualized.BodyRow\n            }\n          }}\n        >\n          <Sticky.Header\n            style={{\n              maxWidth: 800\n            }}\n            ref={tableHeader => {\n              this.tableHeader = tableHeader && tableHeader.getRef();\n            }}\n            tableBody={this.tableBody}\n          />\n\n          <Virtualized.Body\n            rows={rows}\n            rowKey=\"id\"\n            style={{\n              maxWidth: 800,\n              maxHeight: 400\n            }}\n            ref={tableBody => {\n              this.tableBody = tableBody && tableBody.getRef();\n            }}\n            tableHeader={this.tableHeader}\n          />\n        </Table.Provider>\n      </div>\n    );\n  }\n}\n\n<VirtualizedTable />\n```\n\n## Using relative column widths\n\nYou can define column widths as percentages of the table's width, like so:\n\n```javascript\nconst columns = [\n  {\n    property: 'id',\n    props: {\n      style: { width: \"35%\" }\n    },\n    ...\n```\n\nTo force rows to stretch to the full width of the `tbody` container, however, a `flex`-based styling workaround is required. [This StackOverflow answer](http://stackoverflow.com/a/29512692/629578) suggests the configuration below. If this does not work for you, due to other styling constraints or concerns about browser compatibility, you may consider the other answers posted there, or you may need to take care of your column sizing and resizing in JavaScript.\n\n```css\n{\n  display: flex;\n  flex-flow: column;\n\n  thead,\n  tbody tr {\n    display: table;\n    table-layout: fixed;\n  }\n\n  thead {\n    flex: 0 0 auto;\n    width: 100%;\n    background: #eaeaea;\n    tr {\n      width: calc(100% - 0.9em); /* 0.9em approximates scrollbar width */\n      display: table;\n    }\n  }\n\n  tbody {\n    display: block;\n    flex: 1 1 auto;\n    overflow-y: scroll;\n\n    tr {\n      width: 100%;\n    }\n  }\n}\n```\n"}});