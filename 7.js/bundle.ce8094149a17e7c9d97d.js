webpackJsonp([7],{1512:function(n,t,e){var s=e(1),o=e(14),r=e(15).PageRenderer;r.__esModule&&(r=r.default);var a=o({displayName:"WrappedPageRenderer",getInitialState:function(){return{content:e(1545)}},componentWillMount:function(){},render:function(){return s.createElement(r,Object.assign({},this.props,{content:this.state.content}))}});a.__catalog_loader__=!0,n.exports=a},1545:function(n,t){n.exports="[![build status](https://secure.travis-ci.org/reactabular/sortabular.svg)](http://travis-ci.org/reactabular/sortabular) [![bitHound Score](https://www.bithound.io/github/reactabular/sortabular/badges/score.svg)](https://www.bithound.io/github/reactabular/sortabular) [![codecov](https://codecov.io/gh/reactabular/sortabular/branch/master/graph/badge.svg)](https://codecov.io/gh/reactabular/sortabular)\n\n# Sortabular - Sort utilities\n\nSortabular's helpers make it possible to manage sorting related classes and to sort rows based on them.\n\n## API\n\nThe API consists of the sort helpers, transforms, formatters, and strategies. These can be combined together to set up sort in various ways. There's control over the algorithm used as well as how it's bound to the user interface. You can also control how sorting is tracked (per column index or per property).\n\n```javascript\nimport * as sort from 'sortabular';\n\n// Or you can cherry-pick\nimport { byColumn } from 'sortabular';\nimport { byColumn as sortByColumn } from 'sortabular';\n```\n\n### Helpers\n\n**`sort.byColumn({ sortingColumns: <sorting columns>, sortingOrder: {FIRST: <string>, <string>: <string>}, selectedColumn: <string> }) => <sorting colums> || {}`**\n\n`sort.byColumn` allows you to sort per one column. It discards possible existing sorting state. If you are trying to sort the same column, it will cycle between ascending, descending, and no sorting. In case you are trying to sort some other column, it will start from the ascending state while discarding the existing sorting state.\n\n**`sort.byColumns({ sortingColumns: <sorting columns>, sortingOrder: {FIRST: <string>, <string>: <string>}, selectedColumn: <string> }) => <sorting columns> || {}`**\n\n`sort.byColumns` is like `sort.byColumn` except it doesn't discard possible existing sort state and instead accumulates it. This allows you to perform sorting over multiple columns while refining the results. The last-sorted column always has the highest `position` value, i.e. the lowest sorting priority.\n\n**`sort.byColumnsPrioritizeLastSorted({ sortingColumns: <sorting columns>, sortingOrder: {FIRST: <string>, <string>: <string>}, selectedColumn: <string> }) => <sorting columns> || {}`**\n\n`sort.byColumnsPrioritizeLastSorted` is like `sort.byColumns` except it\nalways gives the last-sorted column the highest sorting priority.\n\n**`sort.sorter({ columns: [<object>], sortingColumns: <sorting columns>, sort: <function>, strategy = strategies.byIndex })([<rows to sort>]) => [<sorted rows>]`**\n\n`sort.sorter` sorts the passed `rows` using a `sortingColumns` definitions and a `sort` function. It has been designed to work based on [lodash.orderBy](https://lodash.com/docs#orderBy) signature.\n\nIf you want to evaluate columns in a reverse order instead of the default, you can reverse `sort` function like this:\n\n```javascript\nconst reverseSort = (data, columnIndexList, orderList) => (\n  orderBy(data, columnIndexList.slice().reverse(), orderList.slice().reverse())\n);\n```\n\n### Transforms\n\n**`sort.sort = ({ event = 'onClick', getSortingColumns = () => [], strategy = strategies.byIndex, onSort = (columnIndex) => {} } = {}) => (value, { columnIndex }, props)`**\n\n`sort.sort` can be applied as a transform. It expects `getSortingColumns` and `onSort` callbacks. The former should return the sorting column data, the latter is called when the user sorts based on `event`.\n\n**`sort.reset = ({ event = 'onDoubleClick', getSortingColumns = () => [], strategy = strategies.byIndex, onReset = (columnIndex) => {} } = {}) => (value, { columnIndex }, props)`**\n\n`sort.reset` can be applied as a transform. It expects `getSortingColumns` and `onReset` callbacks. The former should return the sorting column data, the latter is called when the user sorts based on `event`.\n\n### Formatters\n\n**`sort.header = ({ sortable, strategy = strategies.byIndex, getSortingColumns = () => [] }) => (value, { columnIndex })`**\n\n`sort.header` can be used to sort within a header cell. This works well with `sort.reset` since then you can apply both reseting and sorting to the same cell without conflicts. It expects an initialized sortable (i.e., `sort.sort`) and `getSortingColumns`. If sorting is active at a column, it displays the current order number.\n\n`sortable` and `strategy` parameters are optional. `getSortingColumns` is required.\n\nYou can customize `props` of `sort.header` specific portions through the following protocol:\n\n```javascript\nprops = {\n  container: {},\n  value: {},\n  order: {}\n}\n```\n\n**`sort.order = ({ strategy = strategies.byIndex, getSortingColumns = () => [] }) => (value, { columnIndex })`**\n\n`sort.order` can be used to display a sorting arrow widget. It figures out the class name based on the current sorting status. `sort.header` uses this internally.\n\n### Strategies\n\nMost of the functions accept a strategy. This allows you to modify their sorting behavior. By default they'll track sorting by column index. It's possible to change it to sort by property.\n\n**`sort.strategies.byIndex`**\n\n`byIndex` is the default strategy used by other functions. It literally means the system will track sorting per index.\n\n**`sort.strategies.byProperty`**\n\n`byProperty` ties sorting state to column property. This can be useful if you want to retain the sorting state within a column while moving it around.\n\n## Sorting Protocol\n\nSorting relies on a structure like this to describe what is being sorted and in what order:\n\n```javascript\nconst sortingColumns = {\n  0: {\n    direction: 'asc',\n    position: 1\n  },\n  1: {\n    direction: 'desc',\n    position: 0\n  }\n};\n```\n\nIt maps column index to sorting state and can contain multiple sorters.\n\n## Customizing Sorting Order\n\nIt is possible to customize the sorting order of `sort.byColumn` and `sort.byColumns` by passing an object describing the sorting. It should contain `FIRST` key to describe the starting point. The remaining key-value pairs should form a cycle.\n\nAssuming you are using the `sort` transform, the order values are used for generating the classes you see at the user interface.\n\nThe default order cycles between `asc`, `desc`, and `''` (no sort).\n\nYou could implement a custom order cycling between `asc` and `desc` like this:\n\n```javascript\nconst sortingOrder = {\n  FIRST: 'asc',\n  asc: 'desc',\n  desc: 'asc'\n};\n```\n\n## The `sort` Transform\n\nThe `sort` transform has been designed to track when the user requests sorting and render possibly matching sorting condition as a class for styling. In addition you will need to use specific sort helpers to handle the sorting logic. The helpers have been encapsulated within the `sort` module.\n\n**Example:**\n\n```javascript\n...\nimport * as sort from 'sortabular';\n\n...\n\nconst sortable = sort.sort({\n  // Point the transform to your rows. React state can work for this purpose\n  // but you can use a state manager as well.\n  getSortingColumns: () => this.state.sortingColumns || [],\n\n  // The user requested sorting, adjust the sorting state accordingly.\n  // This is a good chance to pass the request through a sorter.\n  onSort: selectedColumn => {\n    this.setState({\n      sortingColumns: sort.byColumns({ // sort.byColumn would work too\n        sortingColumns: this.state.sortingColumns,\n        selectedColumn\n      })\n    });\n  }\n});\n\n...\n\n// Mark a header as sortable\ncolumns: [\n  {\n    property: 'name',\n    header: {\n      label: 'name',\n      transforms: [sortable]\n    }\n  }\n]\n```\n\n## How to Use?\n\nThe general workflow goes as follows:\n\n1. Set up the `sort` transform. Its purpose is to track when the user requests sorting and render possibly matching sorting condition as a class for styling.\n2. Set up a sort helper. There are helpers for sorting per one column (`sort.byColumn`) and one for sorting per multiple columns (`sort.byColumns`). The helpers handle managing sorting conditions and actual sorting. If you have a back-end, you can skip the latter.\n3. Sort the rows before rendering.\n4. Feed the sorted rows to a `Table`.\n\n> You can find suggested default styling for the package at `style.css` in the package root.\n\n**Example:**\n\n```jsx\n/*\nimport React from 'react';\nimport orderBy from 'lodash/orderBy';\nimport * as resolve from 'table-resolver';\nimport * as Table from 'reactabular-table';\nimport * as sort from 'sortabular';\nimport { compose } from 'redux';\n*/\n\nconst initialRows = [\n  {\n    id: 100,\n    name: {\n      first: 'Adam',\n      last: 'West'\n    },\n    age: 10\n  },\n  {\n    id: 101,\n    name: {\n      first: 'Brian',\n      last: 'Eno'\n    },\n    age: 43\n  },\n  {\n    id: 102,\n    name: {\n      first: 'Brian',\n      last: 'Wilson'\n    },\n    age: 23\n  },\n  {\n    id: 103,\n    name: {\n      first: 'Jake',\n      last: 'Dalton'\n    },\n    age: 33\n  },\n  {\n    id: 104,\n    name: {\n      first: 'Jill',\n      last: 'Jackson'\n    },\n    age: 63\n  }\n];\n\nclass SortTable extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const getSortingColumns = () => this.state.sortingColumns || {};\n    const sortable = sort.sort({\n      // Point the transform to your rows. React state can work for this purpose\n      // but you can use a state manager as well.\n      getSortingColumns,\n\n      // The user requested sorting, adjust the sorting state accordingly.\n      // This is a good chance to pass the request through a sorter.\n      onSort: selectedColumn => {\n        this.setState({\n          sortingColumns: sort.byColumns({ // sort.byColumn would work too\n            sortingColumns: this.state.sortingColumns,\n            selectedColumn\n          })\n        });\n      },\n\n      // Use property strategy over index one given we have nested data\n      strategy: sort.strategies.byProperty\n    });\n    const resetable = sort.reset({\n      event: 'onDoubleClick',\n      getSortingColumns,\n      onReset: ({ sortingColumns }) => this.setState({ sortingColumns }),\n      strategy: sort.strategies.byProperty\n    });\n\n    this.state = {\n      // Sort the first column in a descending way by default.\n      // \"asc\" would work too and you can set multiple if you want.\n      sortingColumns: {\n        'name.first': {\n          direction: 'desc',\n          position: 0\n        }\n      },\n      columns: [\n        {\n          header: {\n            label: 'Name'\n          },\n          children: [\n            {\n              property: 'name.first',\n              header: {\n                label: 'First Name',\n                transforms: [resetable],\n                formatters: [\n                  sort.header({\n                    sortable,\n                    getSortingColumns,\n                    strategy: sort.strategies.byProperty\n                  })\n                ]\n              }\n            },\n            {\n              property: 'name.last',\n              header: {\n                label: 'Last Name',\n                transforms: [resetable],\n                formatters: [\n                  sort.header({\n                    sortable,\n                    getSortingColumns,\n                    strategy: sort.strategies.byProperty\n                  })\n                ]\n              }\n            }\n          ]\n        },\n        {\n          property: 'age',\n          header: {\n            label: 'Age',\n            transforms: [resetable],\n            formatters: [\n              sort.header({\n                sortable,\n                getSortingColumns,\n                strategy: sort.strategies.byProperty\n              })\n            ]\n            // Alternative if you don't need reset.\n            // transforms: [sortable]\n          }\n        }\n      ],\n      rows: initialRows\n    };\n  }\n  render() {\n    const { rows, sortingColumns, columns } = this.state;\n    const resolvedColumns = resolve.columnChildren({ columns });\n    const sortedRows = compose(\n      sort.sorter({\n        columns: resolvedColumns,\n        sortingColumns,\n        sort: orderBy,\n        strategy: sort.strategies.byProperty\n      }),\n      resolve.resolve({\n        columns: resolvedColumns,\n        method: resolve.nested\n      })\n    )(rows);\n\n    return (\n      <div>\n        <Table.Provider columns={resolvedColumns}>\n          <Table.Header\n            headerRows={resolve.headerRows({ columns })}\n          />\n\n          <Table.Body rows={sortedRows} rowKey=\"id\" />\n        </Table.Provider>\n      </div>\n    );\n  }\n}\n\n<SortTable />\n```\n\n## License\n\nMIT. See LICENSE for details.\n"}});